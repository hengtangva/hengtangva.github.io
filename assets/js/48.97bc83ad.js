(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{436:function(t,v,e){t.exports=e.p+"assets/img/httpresponse.05b11280.png"},608:function(t,v,e){"use strict";e.r(v);var _=e(42),i=Object(_.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"http-的转态码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-的转态码"}},[t._v("#")]),t._v(" http 的转态码")]),t._v(" "),_("p",[t._v("首先来了解什么是 http 状态码。")]),t._v(" "),_("p",[t._v("http 状态码是响应报文的响应行上的一个数据，让用户知道响应的状态。")]),t._v(" "),_("p",[t._v("看下图：")]),t._v(" "),_("p",[_("img",{attrs:{src:e(436),alt:""}})]),t._v(" "),_("hr"),t._v(" "),_("p",[t._v("再来看状态码的种类")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("102：表示服务器已经收到请求，并正在处理中，但没有响应返回。")])]),t._v(" "),_("li",[_("p",[t._v("200 OK ：表示从客户端发来的请求被正常处理了。")])]),t._v(" "),_("li",[_("p",[t._v("204 No Count ： 表示服务器接收的请求已经成功处理，但在返回的报文中不包含实体的主体部分。"),_("br"),t._v("\n比如当浏览器发出请求后，返回 204，那么浏览器显示的页面不更新。"),_("br"),t._v("\n比如，当浏览器发送 option 请求时，旨在确定是否能向服务器发送请求，这时，服务只需要返回头部，告诉是否可行就行了，不需要主体部分。")])]),t._v(" "),_("li",[_("p",[t._v("206 Partial Content：该状态码表示客户端进行了范围内的请求，而且服务器成功执行了这方面的请求。"),_("br"),t._v("\n有一个请求头部字段叫 Range，当报文的头部出现这个字段如：'Range': byte = 100-200,就表示，我只需要第一百字节到第两百字节中的内容。若服务器成功处理请求，并返回这部分请求，就会在响应头行把状态码设置为 206. 一般是出现在断点续传，比如迅雷这些软件，下载很大的文件，就会返回该类状态码")])]),t._v(" "),_("li",[_("p",[t._v("301 Moved Permanently ：永久重定向，表示请求的资源已经分配了新的 uri 以后应使用资源现在所指的 uri，也就是说，如果已经把资源对应的 uri 当做书签了，那么返回 301 时，书签的 uri 会改成新的 uri。 响应头部会有一个字段 Location: uri。指明了新的uri。比如，你用 https 优化了你的地址，就最好把之前的 http 地址重定向到 https 的那个地址")])]),t._v(" "),_("li",[_("p",[t._v("302 Found ：临时重定向，也是资源放在新的 uri ，但是是临时的，也就是说，就这一次访问用新的 uri，书签不变，下次请求还是老的 uri。")])]),t._v(" "),_("li",[_("p",[t._v("303 See Other : 和 302 很像，但是它要求的是 重定向访问新的 uri 时要用 get 方法。")])])]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),_("p",[t._v("虽然规范中明确指出，不允许在重定向时修改方法，但是所有浏览器都会把 post 改成 get")])]),t._v(" "),_("p",[t._v("虽然 302 重定向的地址可以用任何方法访问，但是还是会被浏览器改成 get。")]),t._v(" "),_("p",[t._v("而我们用 303 只不过明确指出就用 get 罢了，让语义更加清晰。")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("304 Not Modified : 资源没有改变，可以直接使用缓存，简单来说，就是服务器告诉客户端，你这次访问的和上次访问的是一样的，没有必要再重新发一份了，直接使用缓存就 ok 了。")])]),t._v(" "),_("li",[_("p",[t._v("307 Temporary Redirect : 这个是解决 302 无论用什么方法都被浏览器改成 get 的问题。"),_("br"),t._v("\n307，就是告诉你，我就是要用原来的方法，不许改。")])]),t._v(" "),_("li",[_("p",[t._v("400 Bad Request ：该状态码表示请求报文中存在语法错误，或者请求的参数有错误，浏览器会像对待 200 一样，对待该状态码。")])]),t._v(" "),_("li",[_("p",[t._v("401 Unauthorized : 该状态码表示发送的请求需要有通过 HTTP 认证的认证信息，若之前已经进行过一次请求，则表示用户认证失败。 当浏览器初次接受到 401 响应，会弹出认证用的对话窗口。 具体的例子是，比如用 token 进行保存登陆状态的时候，如果 token 过期了，再发送请求，服务端就可以返回  401， 告诉客户端认证过期了，然后重新导航到 登陆页。")])]),t._v(" "),_("li",[_("p",[t._v("403 Forbidden ： 服务器禁止访问 (如从未授权的发送源 ip 地址试图访问)。")])]),t._v(" "),_("li",[_("p",[t._v("404 Not Found ：表示服务器上无法找到请求的资源。")])]),t._v(" "),_("li",[_("p",[t._v("405 Method Not Allowed: 请求方法不被支持，这个最近经常碰到。 一般 put delete 会改动服务器上的资源，所以一般都是默认不允许的。")])]),t._v(" "),_("li",[_("p",[t._v("500 Internal Server Error ：表明服务器在执行请求时，发生了错误，也可能是 web 应用出现 bug 。")])]),t._v(" "),_("li",[_("p",[t._v("503 Service Unavailable : 服务器在忙，处于超负载状态，或正在进行停机维护，现在无法处理请求。")])]),t._v(" "),_("li",[_("p",[t._v("505 HTTP Version Not Supported ：服务器不支持请求报文所用的 http 协议版本。")])])])])}),[],!1,null,null,null);v.default=i.exports}}]);