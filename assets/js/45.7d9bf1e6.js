(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{426:function(t,v,_){t.exports=_.p+"assets/img/tcphead.2f87bd2e.jpg"},602:function(t,v,_){"use strict";_.r(v);var a=_(42),s=Object(a.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"tcp-的报文"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp-的报文"}},[t._v("#")]),t._v(" TCP 的报文")]),t._v(" "),a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),a("p",[t._v("这里详细介绍一下 tcp 的报文结构。")]),t._v(" "),a("p",[t._v("主要是了解 tcp 首部各个字段的作用。")]),t._v(" "),a("p",[t._v("首先， 一个 TCP 包的大小受到 最大报文段限制(MSS)")]),t._v(" "),a("p",[t._v("MSS 通常根据最初确定的由本地发送主机发送的 最大链路层帧长度 即最大传输单元(MTU) 来设置")]),t._v(" "),a("p",[t._v("通俗来说，就是一个 tcp 包不会被下层协议给切成两份传递。")]),t._v(" "),a("p",[t._v("也就是说 tcp首部 + 数据 <= MSS")]),t._v(" "),a("p",[t._v("其报文结构如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:_(426),alt:""}})]),t._v(" "),a("h2",{attrs:{id:"tcp-首部"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp-首部"}},[t._v("#")]),t._v(" TCP 首部")]),t._v(" "),a("p",[t._v("首部一般 20 个字节。")]),t._v(" "),a("h3",{attrs:{id:"源端口号和目的端口号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#源端口号和目的端口号"}},[t._v("#")]),t._v(" 源端口号和目的端口号")]),t._v(" "),a("p",[t._v("这个两个分部占 2 个字节。")]),t._v(" "),a("p",[t._v("源端口号是发生方发生的端口号， 目的端口号是接受方的端口号。")]),t._v(" "),a("p",[t._v("它们是用来多路复用和多路分解的。 这里顺便提一下这两个概念")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("多路分解： 将运输层报文段中的数据交付到正确的套接字的工作，端口号就是各个套接字的标识。可惜想象一下，运输层发来很多数据，但你的不同应用要拿的数据包是不同的，比如 qq， 浏览器。这时候，就得把这些数据包根据各自的目的端口号进行分解。然后交给上层协议，或者说给对应的应用软件。")])]),t._v(" "),a("li",[a("p",[t._v("多路复用： 多路复用就是和上面反这来的，所有的应用都得走传输层这一条路。那么就得有一个标识，表示你是哪来的。这个标识就是源端口号。")])])]),t._v(" "),a("h3",{attrs:{id:"序列号和确认号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#序列号和确认号"}},[t._v("#")]),t._v(" 序列号和确认号")]),t._v(" "),a("p",[t._v("序列号站了 4 个字节。 确认号占 4 个字节")]),t._v(" "),a("p",[t._v("它们在 tcp 简介中说过了，主要是应答的时候保证数据的可靠传输。")]),t._v(" "),a("h3",{attrs:{id:"接收窗口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接收窗口"}},[t._v("#")]),t._v(" 接收窗口")]),t._v(" "),a("p",[t._v("接收窗口在 tcp 的流控制里也说过了。")]),t._v(" "),a("p",[t._v("主要是接受方告诉发送方，自己缓冲区有多少空位，你下一次发送的窗口大小应该是多少。")]),t._v(" "),a("h3",{attrs:{id:"标志字段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标志字段"}},[t._v("#")]),t._v(" 标志字段")]),t._v(" "),a("p",[t._v("标志字段有 6 比特， 分别是 6 个标志")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("ACK : 用于指示确认字段的值是有效的，即该报文段包括一个对已被成功接受报文段的确认。规定连接后 ACK = 1")])]),t._v(" "),a("li",[a("p",[t._v("SYN : 用于建立请求连接")])]),t._v(" "),a("li",[a("p",[t._v("RST : 用于重新建立连接，即连接重置。")])]),t._v(" "),a("li",[a("p",[t._v("FIN : 用于请求断开连接")])]),t._v(" "),a("li",[a("p",[t._v("PSH : 该位置为 1 时，告诉接受方应立即将数据交给上层。不要等缓存慢了再加交付")])]),t._v(" "),a("li",[a("p",[t._v("URG : 该位置为 1 时，表明报文中存在着被发送方上层实体设置为 紧急 的数据，该数据的最后一个字节由 2 字节的紧急数据指针指出。")])])]),t._v(" "),a("h3",{attrs:{id:"校检和-和-紧急数据指针"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#校检和-和-紧急数据指针"}},[t._v("#")]),t._v(" 校检和 和 紧急数据指针")]),t._v(" "),a("p",[t._v("它们都是占 2 个字节。")]),t._v(" "),a("p",[t._v("校检和主要是防止传输中数据出错，采用编码的方式对其进行校检。")]),t._v(" "),a("p",[t._v("紧急数据指针指向报文中的紧急数据末尾字节。表明该数据应当立即交付。")]),t._v(" "),a("h3",{attrs:{id:"首部长度-和-保留未用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#首部长度-和-保留未用"}},[t._v("#")]),t._v(" 首部长度 和 保留未用")]),t._v(" "),a("p",[t._v("首部长度占了 4 字节，由于 TCP 选项字段额原因， TCP 首部的长度是可变的。")]),t._v(" "),a("p",[t._v("通常选项字段是为空的，所以一般 TCP 首部是 20 个字节。")]),t._v(" "),a("h2",{attrs:{id:"选项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#选项"}},[t._v("#")]),t._v(" 选项")]),t._v(" "),a("p",[t._v("该部分主要用于")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("发送方和接收方协商最大报文段 MSS 。")])]),t._v(" "),a("li",[a("p",[t._v("网络拥塞时，用作窗口的调节因子")])])]),t._v(" "),a("h2",{attrs:{id:"数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据"}},[t._v("#")]),t._v(" 数据")]),t._v(" "),a("p",[t._v("里面放的是 应用层传来的 数据包")])])}),[],!1,null,null,null);v.default=s.exports}}]);